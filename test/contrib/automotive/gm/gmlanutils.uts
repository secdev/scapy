% Regression tests for gmlanutil

+ Configuration
~ conf

= Imports
load_layer("can")
conf.contribs['CAN']['swap-bytes'] = False
import os, threading, six, subprocess, time, sys
from subprocess import call
from scapy.consts import LINUX

= Definition of constants, utility functions and mock classes
iface0 = "vcan0"
iface1 = "vcan1"

# function to exit when the can-isotp kernel module is not available
ISOTP_KERNEL_MODULE_AVAILABLE = False
def exit_if_no_isotp_module():
    if not ISOTP_KERNEL_MODULE_AVAILABLE:
        sys.stderr.write("TEST SKIPPED: can-isotp not available" + os.linesep)
        warning("Can't test ISOTP native socket because kernel module is not loaded")
        exit(0)


= Initialize a virtual CAN interface
~ vcan_socket needs_root linux
if 0 != call(["cansend", iface0,  "000#"]):
    # vcan0 is not enabled
    if 0 != call(["sudo", "modprobe", "vcan"]):
        raise Exception("modprobe vcan failed")
    if 0 != call(["sudo", "ip", "link", "add", "name", iface0, "type", "vcan"]):
        print("add %s failed: Maybe it was already up?" % iface0)
    if 0 != call(["sudo", "ip", "link", "set", "dev", iface0, "up"]):
        raise Exception("could not bring up %s" % iface0)

if 0 != call(["cansend", iface0,  "000#"]):
    raise Exception("cansend doesn't work")

if 0 != call(["cansend", iface1,  "000#"]):
    # vcan1 is not enabled
    if 0 != call(["sudo", "modprobe", "vcan"]):
        raise Exception("modprobe vcan failed")
    if 0 != call(["sudo", "ip", "link", "add", "name", iface1, "type", "vcan"]):
        print("add %s failed: Maybe it was already up?" % iface1)
    if 0 != call(["sudo", "ip", "link", "set", "dev", iface1, "up"]):
        raise Exception("could not bring up %s" % iface1)

if 0 != call(["cansend", iface1,  "000#"]):
    raise Exception("cansend doesn't work")

print("CAN should work now")

= Import CANSocket

from scapy.contrib.cansocket_python_can import *

import can as python_can
new_can_socket = lambda iface: CANSocket(bustype='virtual', channel=iface, timeout=0.01)
new_can_socket0 = lambda: CANSocket(bustype='virtual', channel=iface0, timeout=0.01)
new_can_socket1 = lambda: CANSocket(bustype='virtual', channel=iface1, timeout=0.01)

# utility function for draining a can interface, asserting that no packets are there
def drain_bus(iface=iface0, assert_empty=True):
    with new_can_socket(iface) as s:
        pkts = s.sniff(timeout=0.1)
        if assert_empty:
            assert len(pkts) == 0

print("CAN sockets should work now")

= Overwrite definition for vcan_socket systems native sockets
~ vcan_socket not_pypy needs_root linux

if six.PY3 and LINUX:
    from scapy.contrib.cansocket_native import *
    new_can_socket = lambda iface: CANSocket(iface)
    new_can_socket0 = lambda: CANSocket(iface0)
    new_can_socket1 = lambda: CANSocket(iface1)


= Overwrite definition for vcan_socket systems python-can sockets
~ vcan_socket needs_root linux
if "python_can" in CANSocket.__module__:
    new_can_socket = lambda iface: CANSocket(bustype='socketcan', channel=iface, timeout=0.001)
    new_can_socket0 = lambda: CANSocket(bustype='socketcan', channel=iface0, timeout=0.001)
    new_can_socket1 = lambda: CANSocket(bustype='socketcan', channel=iface1, timeout=0.001)

= Verify that a CAN socket can be created and closed
s = new_can_socket(iface0)
s.close()


= Check if can-isotp and can-utils are installed on this system
~ linux
p1 = subprocess.Popen(['lsmod'], stdout = subprocess.PIPE)
p2 = subprocess.Popen(['grep', '^can_isotp'], stdout = subprocess.PIPE, stdin=p1.stdout)
p1.stdout.close()
if p1.wait() == 0 and p2.wait() == 0 and b"can_isotp" in p2.stdout.read():
    p = subprocess.Popen(["isotpsend", "-s1", "-d0", iface0], stdin = subprocess.PIPE)
    p.communicate(b"01")
    if p.returncode == 0:
        ISOTP_KERNEL_MODULE_AVAILABLE = True


+ Syntax check

= Import isotp
conf.contribs['ISOTP'] = {'use-can-isotp-kernel-module': ISOTP_KERNEL_MODULE_AVAILABLE}
load_contrib("isotp")

if six.PY3 and ISOTP_KERNEL_MODULE_AVAILABLE:
    from scapy.contrib.isotp import ISOTPNativeSocket
    ISOTPSocket = ISOTPNativeSocket
    assert ISOTPSocket == ISOTPNativeSocket
else:
    from scapy.contrib.isotp import ISOTPSoftSocket
    ISOTPSocket = ISOTPSoftSocket
    assert ISOTPSocket == ISOTPSoftSocket

############
############
+ Load general modules

= Load contribution layer

load_contrib("automotive.gm.gmlan")
load_contrib("automotive.gm.gmlanutils")

##############################################################################
+ GMLAN_RequestDownload Tests
##############################################################################
= Positive, immediate positive response
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN()/GMLAN_RD(memorySize=4)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x74"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=1) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

= Negative, immediate negative response
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        nr = GMLAN()/GMLAN_NR(requestServiceId=0x34, returnCode=0x22)
        isotpsock2.send(nr)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=1) == False

thread.join(timeout=5)

= Negative, timeout
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=1) == False

############################ Response pending
= Positive, after response pending
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pending = GMLAN()/GMLAN_NR(requestServiceId=0x34, returnCode=0x78)
        isotpsock2.send(pending)
        ack = b"\x74"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=1) == True

thread.join(timeout=5)

= Positive, hold response pending for several messages
tout = 0.3
repeats = 4
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = GMLAN()/GMLAN_NR(requestServiceId=0x34, returnCode=0x78)
        for i in range(repeats):
            isotpsock2.send(ack)
            time.sleep(tout)
        ack = b"\x74"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    starttime = time.time() # may be inaccurate -> on some systems only seconds precision
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=repeats*tout+0.5) == True
    endtime = time.time()
    assert (endtime - starttime) >= tout*repeats

thread.join(timeout=5)

= Negative, negative response after response pending
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pending = GMLAN()/GMLAN_NR(requestServiceId=0x34, returnCode=0x78)
        isotpsock2.send(pending)
        nr = GMLAN()/GMLAN_NR(requestServiceId=0x34, returnCode=0x22)
        isotpsock2.send(nr)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=1) == False

thread.join(timeout=5)

= Negative, timeout after response pending
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pending = GMLAN()/GMLAN_NR(requestServiceId=0x34, returnCode=0x78)
        isotpsock2.send(pending)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=0.3) == False

thread.join(timeout=5)

= Positive, pending message from different service interferes while pending
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pending = GMLAN()/GMLAN_NR(requestServiceId=0x34, returnCode=0x78)
        isotpsock2.send(pending)
        wrongservice = GMLAN()/GMLAN_NR(requestServiceId=0x36, returnCode=0x78)
        isotpsock2.send(wrongservice)
        isotpsock2.send(pending)
        ack = b"\x74"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=1) == True

thread.join(timeout=5)

= Positive, negative response from different service interferes while pending
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pending = GMLAN()/GMLAN_NR(requestServiceId=0x34, returnCode=0x78)
        isotpsock2.send(pending)
        wrongservice = GMLAN()/GMLAN_NR(requestServiceId=0x36, returnCode=0x22)
        isotpsock2.send(wrongservice)
        isotpsock2.send(pending)
        ack = b"\x74"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=1) == True

thread.join(timeout=5)

################### RETRY
= Positive, first: immediate negative response, retry: Positive
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # negative
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN()/GMLAN_RD(memorySize=4)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        nr = GMLAN()/GMLAN_NR(requestServiceId=0x34, returnCode=0x22)
        # positive retry
        print("retry")
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(nr))
        pkt = GMLAN()/GMLAN_RD(memorySize=4)
        print(requ)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x74"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_RequestDownload(isotpsock, 4, timeout=1, retry=1) == True
    assert ecusimSuccessfullyExecuted == True

thread.join(timeout=5)


##############################################################################
+ GMLAN_TransferData Tests
##############################################################################
= Positive, short payload, scheme = 4
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN() / GMLAN_TD(startingAddress=0x40000000,
                                 dataRecord=payload)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 0x40000000, payload, timeout=1) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

= Positive, short payload, scheme = 3
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 3
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN() / GMLAN_TD(startingAddress=0x400000,
                                 dataRecord=payload)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 0x400000, payload, timeout=1) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

= Positive, short payload, scheme = 2
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 2
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted = True
    with new_can_socket0() as isocan1, ISOTPSocket(isocan1, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        time.sleep(0)
        requ = isotpsock2.sniff(count=1, timeout=2, started_callback=started.set)
        pkt = GMLAN() / GMLAN_TD(startingAddress=0x4000, dataRecord=payload)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan2, ISOTPSocket(isocan2, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 0x4000, payload, timeout=2) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

= Negative, short payload
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        nr = GMLAN() / GMLAN_NR(requestServiceId=0x36, returnCode=0x22)
        isotpsock2.send(nr)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 0x40000000, payload, timeout=1) == False

thread.join(timeout=5)

= Negative, timeout

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 0x4000, payload, timeout=1) == False

= Positive, long payload
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN() / GMLAN_TD(startingAddress=0x40000000,
                                 dataRecord=payload*2)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x76"
        # second package with inscreased address
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        pkt = GMLAN() / GMLAN_TD(startingAddress=0x40000010,
                                 dataRecord=payload * 2)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 0x40000000, payload*4, maxmsglen=16, timeout=1) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True


#
= Positive, first part of payload succeeds, second pending, then fails, retry succeeds
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = b"\x76"
        # second package with inscreased address
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        pending = GMLAN() / GMLAN_NR(requestServiceId=0x36, returnCode=0x78)
        isotpsock2.send(pending)
        time.sleep(0.1)
        nr = GMLAN() / GMLAN_NR(requestServiceId=0x36, returnCode=0x22)
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(nr))
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 0x40000000, payload*4, maxmsglen=16, timeout=1, retry=1) == True

thread.join(timeout=5)

############
= Positive, maxmsglen length check -> message is split automatically
* TODO: This test causes an error in ISOTPSoftSockets

exit_if_no_isotp_module()
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
ecusimSuccessfullyExecuted = True
sim_started = threading.Event()
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=3, started_callback=sim_started.set)
        pkt = GMLAN() / GMLAN_TD(startingAddress=0x40000000,
                                 dataRecord=payload*511+payload[:1])
        if len(requ) == 0 or bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
            return
        ack = b"\x76"
        # second package with inscreased address
        requ = isotpsock2.sniff(count=1, timeout=3, started_callback=lambda: isotpsock2.send(ack))
        pkt = GMLAN() / GMLAN_TD(startingAddress=0x40000FF9,
                                 dataRecord=payload[1:])
        if len(requ) == 0 or bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
            return
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.name = "ECUSimulator" + thread.name
thread.start()
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    sim_started.wait(timeout=5)
    assert GMLAN_TransferData(isotpsock, 0x40000000, payload*512, maxmsglen=0x1000000, timeout=8) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

############ Address boundary checks
= Positive, highest possible address for scheme
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 2**32 - 1, payload, timeout=1) == True

thread.join(timeout=5)

= Negative, invalid address (too large for addressing scheme)
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 2**32, payload, timeout=1) == False

thread.join(timeout=5)

= Positive, address zero
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, 0x00, payload, timeout=1) == True

thread.join(timeout=5)

= Negative, negative address
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferData(isotpsock, -1, payload, timeout=1) == False

thread.join(timeout=5)

############################################
+ GMLAN_TransferPayload Tests
############################################
= Positive, short payload
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN()/GMLAN_RD(memorySize=len(payload))
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x74"
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        pkt = GMLAN() / GMLAN_TD(startingAddress=0x40000000,
                                 dataRecord=payload)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x76"
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_TransferPayload(isotpsock, 0x40000000, payload, timeout=1) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True


############################################
+ GMLAN_GetSecurityAccess Tests
############################################
= KeyFunction
keyfunc = lambda seed : seed - 0x1FBE

= Positive scenario, level 1, tests if keyfunction applied properly
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # wait for request
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN()/GMLAN_SA(subfunction=1)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        seedmsg = GMLAN()/GMLAN_SAPR(subfunction=1, securitySeed=0xdead)
        # wait for key
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(seedmsg))
        pkt = GMLAN()/GMLAN_SA(subfunction=2, securityKey=0xbeef)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
            nr = GMLAN() / GMLAN_NR(requestServiceId=0x27, returnCode=0x35)
            isotpsock2.send(nr)
        else:
            pr = GMLAN()/GMLAN_SAPR(subfunction=2)
            isotpsock2.send(pr)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_GetSecurityAccess(isotpsock, keyfunc, level=1, timeout=1) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

= Positive scenario, level 3
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # wait for request
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN()/GMLAN_SA(subfunction=3)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        seedmsg = GMLAN()/GMLAN_SAPR(subfunction=3, securitySeed=0xdead)
        # wait for key
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(seedmsg))
        pkt = GMLAN()/GMLAN_SA(subfunction=4, securityKey=0xbeef)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
            nr = GMLAN() / GMLAN_NR(requestServiceId=0x27, returnCode=0x35)
            isotpsock2.send(nr)
        else:
            pr = GMLAN()/GMLAN_SAPR(subfunction=4)
            isotpsock2.send(pr)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_GetSecurityAccess(isotpsock, keyfunc, level=3, timeout=1) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True


= Negative scenario, invalid password
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # wait for request
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN()/GMLAN_SA(subfunction=1)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        seedmsg = GMLAN()/GMLAN_SAPR(subfunction=1, securitySeed=0xdead)
        # wait for key
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(seedmsg))
        pkt = GMLAN()/GMLAN_SA(subfunction=2, securityKey=0xbabe)
        if bytes(requ[0]) != bytes(pkt):
            nr = GMLAN() / GMLAN_NR(requestServiceId=0x27, returnCode=0x35)
            isotpsock2.send(nr)
        else:
            ecusimSuccessfullyExecuted = False
            pr = GMLAN()/GMLAN_SAPR(subfunction=2)
            isotpsock2.send(pr)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_GetSecurityAccess(isotpsock, keyfunc, level=1, timeout=1) == False

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

= invalid level (not an odd number)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_GetSecurityAccess(isotpsock, keyfunc, level=2, timeout=1) == False

= zero seed
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # wait for request
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        seedmsg = GMLAN()/GMLAN_SAPR(subfunction=1, securitySeed=0x0000)
        isotpsock2.send(seedmsg)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_GetSecurityAccess(isotpsock, keyfunc, level=1, timeout=1) == True

thread.join(timeout=5)

############### retry
= Positive scenario, request timeout, retry works
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # timeout
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        # wait for request
        requ = isotpsock2.sniff(count=1, timeout=3)
        seedmsg = GMLAN()/GMLAN_SAPR(subfunction=1, securitySeed=0xdead)
        # wait for key
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(seedmsg))
        pkt = GMLAN()/GMLAN_SA(subfunction=2, securityKey=0xbeef)
        pr = GMLAN()/GMLAN_SAPR(subfunction=2)
        isotpsock2.send(pr)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_GetSecurityAccess(isotpsock, keyfunc, level=1, timeout=1, retry=1) == True

thread.join(timeout=5)

= Positive scenario, keysend timeout, retry works
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # wait for request
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        seedmsg = GMLAN()/GMLAN_SAPR(subfunction=1, securitySeed=0xdead)
        # timeout
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(seedmsg))
        # retry from start
        requ = isotpsock2.sniff(count=1, timeout=3)
        seedmsg = GMLAN()/GMLAN_SAPR(subfunction=1, securitySeed=0xdead)
        # wait for key
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(seedmsg))
        pr = GMLAN()/GMLAN_SAPR(subfunction=2)
        isotpsock2.send(pr)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_GetSecurityAccess(isotpsock, keyfunc, level=1, timeout=1, retry=1) == True

thread.join(timeout=5)


= Positive scenario, request error, retry works
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # wait for request
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        nr = GMLAN() / GMLAN_NR(requestServiceId=0x27, returnCode=0x37)
        # wait for request
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(nr))
        seedmsg = GMLAN()/GMLAN_SAPR(subfunction=1, securitySeed=0xdead)
        # wait for key
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(seedmsg))
        pkt = GMLAN()/GMLAN_SA(subfunction=2, securityKey=0xbeef)
        pr = GMLAN()/GMLAN_SAPR(subfunction=2)
        isotpsock2.send(pr)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_GetSecurityAccess(isotpsock, keyfunc, level=1, timeout=1, retry=1) == True

thread.join(timeout=5)


##############################################################################
+ GMLAN_InitDiagnostics Tests
##############################################################################
= sequence of the correct messages
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN(b"\x28")
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x68"
        # ReportProgrammedState
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        pkt = GMLAN(b"\xa2")
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = GMLAN()/GMLAN_RPSPR(programmedState=0)
        # ProgrammingMode requestProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        pkt = GMLAN() / GMLAN_PM(subfunction=0x1)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = GMLAN(b"\xe5")
        # InitiateProgramming enableProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        pkt = GMLAN() / GMLAN_PM(subfunction=0x3)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

= sequence of the correct messages, disablenormalcommunication as broadcast
* TODO: This test errors if executed with ISOTPSoftSockets

exit_if_no_isotp_module()
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2, \
        new_can_socket(iface0) as broadcastrcv:
        print("DisableNormalCommunication")
        requ = broadcastrcv.sniff(count=1, timeout=2, started_callback=started.set)
        pkt = GMLAN(b"\x28")
        print(requ)
        assert len(requ) >= 1
        if bytes(requ[0].data) != b"\xfe\x01" + bytes(pkt):
            ecusimSuccessfullyExecuted = False
        print("ReportProgrammedState")
        requ = isotpsock2.sniff(count=1, timeout=2)
        pkt = GMLAN(b"\xa2")
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = GMLAN()/GMLAN_RPSPR(programmedState=0)
        print("ProgrammingMode requestProgramming")
        requ = isotpsock2.sniff(count=1, timeout=2, started_callback=lambda: isotpsock2.send(ack))
        pkt = GMLAN() / GMLAN_PM(subfunction=0x1)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = GMLAN(b"\xe5")
        print("InitiateProgramming enableProgramming")
        requ = isotpsock2.sniff(count=1, timeout=2, started_callback=lambda: isotpsock2.send(ack))
        pkt = GMLAN() / GMLAN_PM(subfunction=0x3)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, broadcastsocket=GMLAN_BroadcastSocket(new_can_socket(iface0)), timeout=8, verbose=1) == True

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True


######## timeout
= timeout DisableNormalCommunication
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN(b"\x28")
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1) == False

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True


= timeout ReportProgrammedState
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN(b"\x28")
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x68"
        # ReportProgrammedState
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        pkt = GMLAN(b"\xa2")
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = GMLAN()/GMLAN_RPSPR(programmedState=0)
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1) == False

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True


= timeout ProgrammingMode requestProgramming
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN(b"\x28")
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = b"\x68"
        # ReportProgrammedState
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        pkt = GMLAN(b"\xa2")
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = GMLAN()/GMLAN_RPSPR(programmedState=0)
        # ProgrammingMode requestProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        pkt = GMLAN() / GMLAN_PM(subfunction=0x1)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1) == False

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

###### negative respone
= timeout DisableNormalCommunication
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN(b"\x28")
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = GMLAN() / GMLAN_NR(requestServiceId=0x28, returnCode=0x12)
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1) == False

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

###### retry tests
= sequence of the correct messages, retry set 
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = b"\x68"
        # ReportProgrammedState
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN()/GMLAN_RPSPR(programmedState=0)
        # ProgrammingMode requestProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN(b"\xe5")
        # InitiateProgramming enableProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1, retry=0) == True

thread.join(timeout=5)


= negative response, make sure no retries are made
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = GMLAN() / GMLAN_NR(requestServiceId=0x28, returnCode=0x12)
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        if len(requ) != 0:
            ecusimSuccessfullyExecuted = False

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1, retry=0) == False

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True


= first fail at DisableNormalCommunication, then sequence of the correct messages
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = GMLAN() / GMLAN_NR(requestServiceId=0x28, returnCode=0x12)
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = b"\x68"
        # ReportProgrammedState
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN()/GMLAN_RPSPR(programmedState=0)
        # ProgrammingMode requestProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN(b"\xe5")
        # InitiateProgramming enableProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1, retry=1) == True

thread.join(timeout=5)

= first fail at ReportProgrammedState, then sequence of the correct messages
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = b"\x68"
        # Fail
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN() / GMLAN_NR(requestServiceId=0xA2, returnCode=0x12)
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = b"\x68"
        # ReportProgrammedState
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN()/GMLAN_RPSPR(programmedState=0)
        # ProgrammingMode requestProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN(b"\xe5")
        # InitiateProgramming enableProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1, retry=1) == True

thread.join(timeout=5)

= first fail at ProgrammingMode requestProgramming, then sequence of the correct messages
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = b"\x68"
        # ReportProgrammedState
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN()/GMLAN_RPSPR(programmedState=0)
        # Fail
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN() / GMLAN_NR(requestServiceId=0xA5, returnCode=0x12)
        # DisableNormalCommunication
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = b"\x68"
        # ReportProgrammedState
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN()/GMLAN_RPSPR(programmedState=0)
        # ProgrammingMode requestProgramming
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN(b"\xe5")
        isotpsock2.send(ack)
        # InitiateProgramming enableProgramming
        requ = isotpsock2.sniff(count=1, timeout=1)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1, retry=1) == True

thread.join(timeout=5)

= fail twice
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = GMLAN() / GMLAN_NR(requestServiceId=0x28, returnCode=0x12)
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN() / GMLAN_NR(requestServiceId=0x28, returnCode=0x12)
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        if len(requ) != 0:
            ecusimSuccessfullyExecuted = False

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)

with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_InitDiagnostics(isotpsock, timeout=1, verbose=1, retry=1) == False

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True

##############################################################################
+ GMLAN_ReadMemoryByAddress Tests
##############################################################################
= Positive, short length, scheme = 4
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
ecusimSuccessfullyExecuted = True
started = threading.Event()
def ecusim():
    global ecusimSuccessfullyExecuted
    ecusimSuccessfullyExecuted= True
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        pkt = GMLAN() / GMLAN_RMBA(memoryAddress=0x0, memorySize=0x8)
        if bytes(requ[0]) != bytes(pkt):
            ecusimSuccessfullyExecuted = False
        ack = GMLAN() / GMLAN_RMBAPR(memoryAddress=0x0, dataRecord=payload)
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_ReadMemoryByAddress(isotpsock, 0x0, 0x8, timeout=1) == payload

thread.join(timeout=5)
assert ecusimSuccessfullyExecuted == True


= Negative, negative response
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = GMLAN() / GMLAN_NR(requestServiceId=0x23, returnCode=0x31)
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_ReadMemoryByAddress(isotpsock, 0x0, 0x8, timeout=1) is None

thread.join(timeout=5)

= Negative, timeout
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_ReadMemoryByAddress(isotpsock, 0x0, 0x8, timeout=1) is None

###### RETRY
= Positive, negative response, retry succeeds
conf.contribs['GMLAN']['GMLAN_ECU_AddressingScheme'] = 4
payload = b"\x00\x11\x22\x33\x44\x55\x66\x77"
started = threading.Event()
def ecusim():
    with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x642, did=0x242, basecls=GMLAN) as isotpsock2:
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=started.set)
        ack = GMLAN() / GMLAN_NR(requestServiceId=0x23, returnCode=0x31)
        requ = isotpsock2.sniff(count=1, timeout=1, started_callback=lambda:isotpsock2.send(ack))
        ack = GMLAN() / GMLAN_RMBAPR(memoryAddress=0x0, dataRecord=payload)
        isotpsock2.send(ack)

thread = threading.Thread(target=ecusim)
thread.start()
started.wait(timeout=5)
with new_can_socket0() as isocan, ISOTPSocket(isocan, sid=0x242, did=0x642, basecls=GMLAN) as isotpsock:
    assert GMLAN_ReadMemoryByAddress(isotpsock, 0x0, 0x8, timeout=1, retry=1) == payload

thread.join(timeout=5)

+ Cleanup

= Delete vcan interfaces
~ vcan_socket needs_root linux

if 0 != call(["sudo", "ip", "link", "delete", iface0]):
        raise Exception("%s could not be deleted" % iface0)

if 0 != call(["sudo", "ip", "link", "delete", iface1]):
        raise Exception("%s could not be deleted" % iface1)
