% DCE/RPC layer test campaign

+ Syntax check
= Import the DCE/RPC layer
import re
from scapy.layers.dcerpc import *
from uuid import UUID


+ Check EField

= Little Endian IntField getfield
f = EField(IntField('f', 0), '<')
f.getfield(None, hex_bytes('0102030405')) == (b'\x05', 0x04030201)

= Little Endian IntField addfield
f = EField(IntField('f', 0), '<')
f.addfield(None, b'\x01', 0x05040302) == hex_bytes('0102030405')

= Big Endian IntField getfield
f = EField(IntField('f', 0), '>')
f.getfield(None, hex_bytes('0102030405')) == (b'\x05', 0x01020304)

= Big Endian IntField addfield
f = EField(IntField('f', 0), '>')
f.addfield(None, b'\x01', 0x02030405) == hex_bytes('0102030405')

= Little Endian StrField getfield
f = EField(StrField('f', 0), '<')
f.getfield(None, '0102030405') == (b'', '0102030405')

= Little Endian StrField addfield
f = EField(StrField('f', 0), '<')
f.addfield(None, b'01', '02030405') == b'0102030405'

= Big Endian StrField getfield
f = EField(StrField('f', 0), '>')
f.getfield(None, '0102030405') == (b'', '0102030405')

= Big Endian StrField addfield
f = EField(StrField('f', 0), '>')
f.addfield(None, b'01', '02030405') == b'0102030405'

= Little Endian UUIDField getfield
* The endianness of a UUIDField should be apply by block on each block in
* parenthesis '(01234567)-(89ab)-(cdef)-(01)(23)-(45)(67)(89)(ab)(cd)(ef)'

f = EField(UUIDField('f', None), '<')
f.getfield(None, hex_bytes('0123456789abcdef0123456789abcdef')) == (b'', UUID('67452301-ab89-efcd-0123-456789abcdef'))

= Little Endian UUIDField addfield
f = EField(UUIDField('f', '01234567-89ab-cdef-0123-456789abcdef'), '<')
f.addfield(None, b'', f.default) == hex_bytes('67452301ab89efcd0123456789abcdef')

= Big Endian UUIDField getfield
f = EField(UUIDField('f', None), '>')
f.getfield(None, hex_bytes('0123456789abcdef0123456789abcdef')) == (b'', UUID('01234567-89ab-cdef-0123456789abcdef'))

= Big Endian UUIDField addfield
f = EField(UUIDField('f', '01234567-89ab-cdef-0123-456789abcdef'), '>')
f.addfield(None, b'', f.default) == hex_bytes('0123456789abcdef0123456789abcdef')

+ DCE/RPC v5

= Dissect DCE/RPC v5 Request with Kerberos GSSAPI/RFC1964

pkt = DceRpc(b"\x05\x00\x00\x03\x10\x00\x00\x00\xcd\x00-\x00\x01\x00\x00\x00x\x00\x00\x00\x00\x00\x00\x00j\x87\xb4\xa8DrE3\xfa\xc1\x1d\x9e\xb7\x8a_\xffr\xbe\x13\xc4<\x85\xf0\xf2'y\x84t%u|e\xef/\x04\xb0m\x98\xb1\xd2\x00KwW#P\x8f2\xecB\x81\x19\xf3g\xd2o[\x07L-\xb8\x89\x05\xcf?\xcf\t\xeb\xb3&&6\xb7\x84\xb6\xcd8Ao\x8c\x94\xca\x03\xe3\x0e\x86'-\xfaHj\xcez\xf0A\x83\x9dX\r\xe8\x96\x07Bs\xaf\x9c[=2\x9eS\xb1\x18\x84 \xb4y\n9\xdf\x92\x1c\xd8\xe2e\xd3^,\t\x06\x08\x00pj\x8f\x04`+\x06\t*\x86H\x86\xf7\x12\x01\x02\x02\x02\x01\x11\x00\x10\x00\xff\xffp\xc0\\m\xfe\xa4\xe1!\xf7\xdf\xbf\xa4\xad\xdf\xcb\x16\x1e\xb5+{\x97\xaf\xd5~")
assert pkt.auth_verifier.auth_type == 9
assert pkt.auth_verifier.auth_value.MechType.oidname == 'Kerberos 5'
assert isinstance(pkt.auth_verifier.auth_value.innerContextToken, KRB5_GSS_Wrap_RFC1964)
assert DceRpc5Request in pkt
assert pkt[DceRpc5Request].alloc_hint == 120
assert pkt[DceRpc5Request].opnum == 0

= Dissect DCE/RPC v5 Request EPM map request

pkt = Ether(b'\x00\x0c)\xe1\xde{\x00\x0c)\x05\xe0\xd9\x08\x00E\x00\x00\xc4"\x92@\x00\x80\x06\xb3\x86\n\x01\x0f\x19\n\x01\x01\x01\x05=\x00\x87\x1e\x1b\x8f\x12\x02\x8ee\x19P\x18\xff\xb7 ^\x00\x00\x05\x00\x00\x03\x10\x00\x00\x00\x9c\x00\x00\x00\x01\x00\x00\x00\x84\x00\x00\x00\x00\x00\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00K\x00\x00\x00K\x00\x00\x00\x05\x00\x13\x00\r5BQ\xe3\x06K\xd1\x11\xab\x04\x00\xc0O\xc2\xdc\xd2\x04\x00\x02\x00\x00\x00\x13\x00\r\x04]\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00+\x10H`\x02\x00\x02\x00\x00\x00\x01\x00\x0b\x02\x00\x00\x00\x01\x00\x07\x02\x00\x00\x87\x01\x00\t\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00')
assert pkt.auth_verifier is None
assert pkt[DceRpc5Request].alloc_hint == 132
assert pkt[DceRpc5Request].opnum == 3 

= Dissect DCE/RPC v5 Bind request with NETLOGON secure channel

pkt = DceRpc(b'\x05\x00\x0b\x07\x10\x00\x00\x00\xe4\x00<\x00\x02\x00\x00\x00\xd0\x16\xd0\x16\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x01\x00xV4\x124\x12\xcd\xab\xef\x00\x01#Eg\xcf\xfb\x01\x00\x00\x00\x04]\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00+\x10H`\x02\x00\x00\x00\x01\x00\x01\x00xV4\x124\x12\xcd\xab\xef\x00\x01#Eg\xcf\xfb\x01\x00\x00\x003\x05qq\xba\xbe7I\x83\x19\xb5\xdb\xef\x9c\xcc6\x01\x00\x00\x00\x02\x00\x01\x00xV4\x124\x12\xcd\xab\xef\x00\x01#Eg\xcf\xfb\x01\x00\x00\x00,\x1c\xb7l\x12\x98@E\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00D\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x17\x00\x00\x00APPS2019\x00APPS2019-RODC\x00\x08apps2019\x03lab\x00\rAPPS2019-RODC\x00')

assert pkt.auth_verifier.auth_value.NetbiosDomainName == b"APPS2019"
assert pkt.auth_verifier.auth_value.DnsDomainName == b"apps2019.lab."

assert pkt.n_context_elem == 3
assert pkt[DceRpc5Bind].context_elem[0].transfer_syntaxes[0].sprintf("%if_uuid%") == 'NDR 2.0'
assert pkt[DceRpc5Bind].context_elem[1].transfer_syntaxes[0].sprintf("%if_uuid%") == 'NDR64'
assert pkt[DceRpc5Bind].context_elem[2].transfer_syntaxes[0].sprintf("%if_uuid%") == 'Bind Time Feature Negotiation'

= Dissect DCE/RPC v5 Bind Response with NETLOGON secure channel

pkt = DceRpc(b'\x05\x00\x0c\x07\x10\x00\x00\x00\x80\x00\x0c\x00\x02\x00\x00\x00\xd0\x16\xd0\x16=F\x00\x00\x06\x0049676\x00\x03\x00\x00\x00\x02\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x003\x05qq\xba\xbe7I\x83\x19\xb5\xdb\xef\x9c\xcc6\x01\x00\x00\x00\x03\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00D\x06\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
assert pkt[DceRpc5BindAck].sec_addr.port_spec == b'49676\x00'
assert pkt[DceRpc5BindAck].results[1].result == 0
assert pkt[DceRpc5BindAck].results[1].transfer_syntax.sprintf("%if_uuid%") == 'NDR64'

= Dissect DCE/RPC v5 Response with NETLOGON secure channel

pkt = DceRpc(b'\x05\x00\x02\x03\x10\x00\x00\x00\x98\x038\x00\x02\x00\x00\x004\x03\x00\x00\x01\x00\x00\x00\x88\xd6k\xac\xab^\xafqA^\xee\x8e\xce\x16\x86i\xe5A\xafK#\xeb%\'l\x88\xd4A\x0f\xa6>\xaf\xed\xf65\xf0\xf9\xf25\x89\xf5\xc5r\xe6;t\xf5\x80 \x80~\xf6\x0cRQ\x0b\xea\xc2}\x8a>\x08\xc9\x04\x9c\xdcOj\xa3\x0c\x82~\xfe\xa6\xa3\x01^ \xee\xd3\xd2yf\xfa\xfbL\xec&\x8b60\xb9\x83j\x84\xa0\xbc*G\xe25\x1a\r\xf3\xc8\xa6ib9\x87\xcbt%\x17\xf8g\x17\x1cIR\xd5\'wW\xbedZbXv\xb7\xe5?#$(\xae\x06\x9e\xce\xe1K\xd9\'\x9fG\xde\xff\xc9j\xd7\xa4\x04\xcb]-\xbcr\xb9+\xdax\xee\xa3\xce\x9c\x15\x0c/\xb2\xcb\xaaF\t\x07/AQM\x18t\xdc\xea\x019\x11TOy\xf7\x7f\xd1\x87\xc7m\xea>\x84Y\xc3\xef\xd0\xa6e\xb0g\xc3\x12\xd9\xc4~$\xb8\xfc/0\x86\x0e0\x8c`5lU\xd1\xbf8\xd2\xcb\xb1%\xfa\xfabr\x10\x9a\xf8\xb7\xb1\x01$wU\x17r\x03Z\xdc\xdd^\xecU\xc1\xf1\x87\xad\xa1\xea\xd8\xf2\x82\xa8\x95\xd4\xd2\xc6\x8e\xf1\xcfN1k\xdc\xc3\xf7o]q\'a\xa3Y\r97\xfe.8O\xf9\xa7\x93\xd3\x99?K\x8bv.\xac=t\r\xba\xca\xd0\x82\xd8\x81\xaf\xe6cv\xbe\xcbN\x93\x9d\x0e\xd4\x119d\x83/u\xc8\xb2\x1c/q\xf0"\xc4\x04\xadB\xe3N\xed\xbbR\xc4yO\x1fQ\xdd}\xd2\xe3c\x1e\xec\xc7\xc4\xf8\xf6OV\xe5\x00*\xb0\t\xbd\xf0\xe5j\xbf\xa3\xe0\x85\xa0\x81\xc6\xb96\xb9\xec\xd7I\x16_\xe7K\xb2D\xad\xb5\x7fG\xb9\x9by\xe2\xd9\xcf\xe7J\x83Y-\xa7:\xa3\x16\xe7\xce\xf9\xf5\xeb\x88z&Je\xcb\x94\'\xdc?\xbf\xed!\x1a\xb3sI\xb5o\x00\x8dJ\xd9\xed\x160+\x11nD\xd0QIo]A\xc0\x89\xa8\xb2\xc9\xb6\xc7,\xf0V\x8a\xae\xa6\x97\x8e\x91tO\x8c\x94\x08\xf1ru\x87e\x0bq6\x8aZ\xb9\xf3\xb7\xbb\xaf;\x89\xdf\x8b\xbf\tA\xef\xe3\x07\x0fT\xed\xbb\x072\x8eQ\xf4\xce\x194A\\w\xb4\x88\xff[\xcf\x91N\x1b\xfb\xe3\xcb~\xe9\xfc\x195\x0f&96\x05\x9a\xe4\xc0~\xd9\x0b\xfd\xbc\xc9\x8fTXY\x9f\xe4\x87e!\x93$$\x0b\xfc\xe7Jm8\x18\xb5\xad\xff\x85\xc3\xe2%\xd5{\x8bs\xa7\xb0\x1e\x0ei<v?\xd4\xd5\x12L\x1dBfj[\x99\x90\xf4p\x7f\xbbx\x01\xe9\x055\x9b\xc2\xc5X\x11~\x98\x8b,\x17\xd5\xf0b=\x0c\xd0\x9d3\xb3\xde\x8b\xfbS\x8e5\x82U\x1bz\xf3\xa4E\xcbsri\x01`\x82\x16\xaa\xab\x84\x15\x93\xf4\x86{\x94\x10b\xc50\x90\x93\x84mH\xf0\xeb\xbfh{#\xe1\xa2\xa1\x97\x7fQ\x90\xc0\xedC\x8e\xdc\xd4{\x84\xf2zb\xe12\x1cK\x91\xe8\xc3\xd6\xf1\x1a\xf1:o4\xba\xfd~L.\xe8\xf3`L\xec\xe3\xea\xf5\xca\x95y\xc0\x15T\xce\xec\xa2wtS\xfa\x07\x06me\x15m\xacy"\x15O\xdc\xcf"\x8d\xdc\xd4\xaa\x7f\xbf\x04\xee\xd1rY\x14|\xa4\xe3rjG&\xd0\xaf?\xcf\xd2\xd1%\xb0\x1a\xa5\x95e$\xd5-\x92t!+}}\xf6\x17\xb5\x04\xe7\xf8\xd7\xe2\x0bE\xed\xbc\xa2\xab\x92\xf5\xd5\t\xb4P\xf9\x95\xb1B\xdey\xf7hi2(\xe5B\xb8s\xb98;\x81\xd0;\x173\xb1\x82\x0e\xe0\xb6\x88i\xa7M\x99\x16\x96+\x02yD\x06\x0c\x00\x00\x00\x00\x00\x13\x00\x1a\x00\xff\xff\x00\x00\xd2\xd27\xc2sC\xc4"G\x91\xb3\n\xf9\xb5=O?\xeb\x15|\xdd\xed\x1c\xde\xa1l!p\x01\xe9\x06L\xf1i45\xfajY\xbc\x03\xdd\x8bg\xe1\xd3\xed\x91')
assert pkt.auth_verifier.auth_value.sprintf("%SignatureAlgorithm%") == 'HMAC-SHA256'
assert pkt.auth_verifier.auth_value.SequenceNumber == 2505201457183576786
assert len(pkt.load) == 832

+ Check DCE/RPC 4 layer

= DCE/RPC default values
assert bytes(DceRpc4()) == b'\x04\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00'

= DCE/RPC payload length computation
assert bytes(DceRpc4() / b'\x00\x01\x02\x03') == b'\x04\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x04\x00\x00\x00\x00\x00\x00\x01\x02\x03'

= DCE/RPC Guess payload class fallback with no possible payload
p = DceRpc(hex_bytes('04000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000ffffffff00040000000000010203'))
p.payload.__class__ == conf.raw_layer

= DCE/RPC Guess payload class to a registered heuristic payload
* A payload to be valid must implement the method can_handle and be registered to DceRpcPayload
from scapy.layers.dcerpc import *; import binascii, re
class DummyPayload(Packet):
  fields_desc = [StrField('load', '')]
  @classmethod
  def can_handle(cls, pkt, dce):
    if pkt[0] in [b'\x01', 1]:  # support for py3 bytearray
      return True
    else:
      return False

DceRpc4Payload.register_possible_payload(DummyPayload)
p = DceRpc(hex_bytes('04000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000ffffffff00040000000001020304'))
p.payload.__class__ == DummyPayload

= DCE/RPC Guess payload class fallback with possible payload classes
p = DceRpc(hex_bytes('04000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000ffffffff00040000000000010203'))
p.payload.__class__ == conf.raw_layer

= DCE/RPC little-endian build
bytes(DceRpc4(ptype='response', endian='little', opnum=3) / b'\x00\x01\x02\x03') == hex_bytes('04020000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000300ffffffff04000000000000010203')

= DCE/RPC little-endian dissection
p = DceRpc(hex_bytes('04020000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000300ffffffff04000000000000010203'))
p.ptype == 2 and p.opnum == 3 and p.len == 4
