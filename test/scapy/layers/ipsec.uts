##############################
% IPsec layer regression tests
##############################

~ crypto

###############################################################################
+ IPv4 / ESP - Transport - Encryption Algorithms

#######################################
= IPv4 / ESP - Transport - NULL - NULL
~ -crypto

import socket

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Transport - DES - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='DES', crypt_key=b'8bytekey',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an ESP layer
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

# Generated with Linux 4.4.0-62-generic #83-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 546 reqid 1 \
#    mode tunnel enc 'cbc(des)' '0x38627974656b6579' auth digest_null '' flag align4
ref = IP() \
    / ESP(spi=0x222,
          data=b'\x0f\x6d\x2f\x3d\x1e\xc1\x0b\xc2\xb6\x8f\xfd\x67\x39\xc0\x96\x2c'
               b'\x17\x79\x88\xf6\xbc\x4d\xf7\x45\xd8\x36\x63\x86\xcd\x08\x7c\x08'
               b'\x2b\xf8\xa2\x91\x18\x21\x88\xd9\x26\x00\xc5\x21\x24\xbf\x8f\xf5'
               b'\x6c\x47\xb0\x3a\x8e\xdb\x75\x21\xd9\x33\x85\x5a\x15\xc6\x31\x00'
               b'\x1c\xef\x3e\x12\xce\x70\xec\x8f\x48\xc7\x81\x9b\x66\xcb\xf5\x39'
               b'\x91\xb3\x8e\x72\xfb\x7f\x64\x65\x6c\xf4\xa9\xf2\x5e\x63\x2f\x60',
          seq=1)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)

#######################################
= IPv4 / ESP - Transport - 3DES - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='3DES', crypt_key=b'threedifferent8byteskeys',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an ESP layer
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

# Generated with Linux 4.4.0-62-generic #83-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 546 reqid 1 \
#   mode tunnel enc 'cbc(des3_ede)' '0x7468726565646966666572656e743862797465736b657973' auth digest_null '' flag align4
ref = IP() \
    / ESP(spi=0x222,
          data=b'\x36\x5c\x9b\x41\x37\xc8\x59\x1e\x39\x63\xe8\x6b\xf7\x0d\x97\x54'
               b'\x13\x84\xf6\x81\x66\x19\xe7\xcb\x75\x94\xf1\x0b\x8e\xa3\xf1\xa0'
               b'\x3e\x88\x51\xc4\x50\xd0\xa9\x1f\x16\x25\xc6\xbd\xe9\x0b\xdc\xae'
               b'\xf8\x13\x00\xa3\x8c\x53\xee\x1c\x96\xc0\xfe\x99\x70\xab\x94\x77'
               b'\xd7\xc4\xe8\xfd\x9f\x96\x28\xb8\x95\x20\x86\x7b\x19\xbc\x8f\xf5'
               b'\x96\xb0\x7e\xcc\x04\x83\xae\x4d\xa3\xba\x1d\x44\xf0\xba\x2e\xcd',
          seq=1)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)

#######################################
= IPv4 / ESP - Transport - AES-CBC - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

# Generated with Linux 4.4.0-62-generic #83-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 546 reqid 1 \
#   mode tunnel enc 'cbc(aes)' '0x7369787465656e6279746573206b6579' auth digest_null '' flag align4
ref = IP() \
    / ESP(spi=0x222,
          data=b'\x08\x2f\x94\xe6\x53\xd8\x8e\x13\x70\xe8\xff\x61\x52\x90\x27\x3c'
               b'\xf2\xb4\x1f\x75\xd2\xa0\xac\xae\x1c\xa8\x5e\x1c\x78\x21\x4c\x7f'
               b'\xc3\x30\x17\x6a\x8d\xf3\xb1\xa7\xd1\xa8\x42\x01\xd6\x8d\x2d\x7e'
               b'\x5d\x06\xdf\xaa\x05\x27\x42\xb1\x00\x12\xcf\xff\x64\x02\x5a\x40'
               b'\xcd\xca\x1b\x91\xba\xf8\xc8\x59\xe7\xbd\x4d\x19\xb4\x8d\x39\x25'
               b'\x6c\x73\xf1\x2d\xaa\xee\xe1\x0b\x71\xcd\xfc\x11\x1d\x56\xce\x60'
               b'\xed\xd2\x32\x87\xd4\x90\xc3\xf5\x31\x47\x97\x69\x83\x82\x6d\x38',
          seq=1)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)

#######################################
= IPv4 / ESP - Transport - AES-CTR - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CTR', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

# Generated with Linux 4.4.0-62-generic #83-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 546 reqid 1 \
#    mode tunnel enc 'rfc3686(ctr(aes))' '0x3136627974656b65792b34627974656e6f6e6365' auth digest_null '' flag align4
ref = IP() \
    / ESP(spi=0x222,
          data=b'\xc4\xca\x09\x0f\x8b\xd3\x05\x3d\xac\x5a\x2f\x87\xca\x71\x10\x01'
               b'\xa7\x95\xc9\x07\xcc\xd4\x05\x58\x65\x23\x22\x4b\x63\x9b\x1f\xef'
               b'\x55\xb9\x1a\x91\x52\x76\x00\xf7\x94\x7b\x1d\xe1\x8e\x03\x2e\x85'
               b'\xad\xdd\x83\x22\x8a\xc3\x88\x6e\x85\xf5\x9b\xed\xa9\x6e\xb1\xc3'
               b'\x78\x00\x2f\xcd\x77\xe8\x3e\xec\x0e\x77\x94\xb2\x9b\x0f\x64\x5e'
               b'\x09\x83\x03\x7d\x83\x22\x39\xbb\x94\x66\xae\x9f\xbf\x01\xda\xfb',
          seq=1)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)

#######################################
= IPv4 / ESP - Transport - Blowfish - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='Blowfish', crypt_key=b'sixteenbytes key',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

# Generated with Linux 4.4.0-62-generic #83-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 546 reqid 1 \
#    mode tunnel enc 'cbc(blowfish)' '0x7369787465656e6279746573206b6579' auth digest_null '' flag align4
ref = IP() \
    / ESP(spi=0x222,
          data=b'\x93\x9f\x5a\x10\x55\x57\x30\xa0\xb4\x00\x72\x1e\x46\x42\x46\x20'
               b'\xbc\x01\xef\xc3\x79\xcc\x3e\x55\x64\xba\x09\xc2\x6a\x5a\x5c\xb3'
               b'\xcc\xb5\xd5\x87\x82\xb0\x0a\x94\x58\xfc\x50\x37\x40\xe1\x03\xd3'
               b'\x4a\x09\xb2\x23\x53\x56\xa4\x45\x4c\xbb\x81\x1c\xdb\x31\xa7\x67'
               b'\xbd\x38\x8e\xba\x55\xd9\x1f\xf1\x3c\xeb\x07\x4c\x02\xb0\x3e\xc5'
               b'\xf6\x60\xdd\x68\xe1\xd4\xec\xee\x27\xc0\x6d\x1a\x80\xe2\xcc\x7d',
          seq=1)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)

#######################################
= IPv4 / ESP - Transport - CAST - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='CAST', crypt_key=b'sixteenbytes key',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

# Generated with Linux 4.4.0-62-generic #83-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 546 reqid 1 \
#    mode tunnel enc 'cbc(cast5)' '0x7369787465656e6279746573206b6579' auth digest_null '' flag align4
ref = IP() \
    / ESP(spi=0x222,
          data=b'\xcd\x4a\x46\x05\x51\x54\x73\x35\x1d\xad\x4b\x10\xc1\x15\xe2\x70'
               b'\xbc\x9c\x53\x8f\x4d\x1c\x87\x1a\xc1\xb0\xdf\x80\xd1\x0c\xa4\x59'
               b'\xe6\x50\xde\x46\xdb\x3f\x28\xc2\xda\x6c\x2b\x81\x5e\x7c\x7b\x4f'
               b'\xbc\x8d\xc1\x6d\x4a\x2b\x04\x91\x9e\xc4\x0b\xba\x05\xba\x3b\x71'
               b'\xac\xe3\x16\xcf\x7f\x00\xc5\x87\x7d\x72\x48\xe6\x5b\x43\x19\x24'
               b'\xae\xa6\x2c\xcc\xad\xbf\x37\x6c\x6e\xea\x71\x67\x73\xd6\x11\x9f',
          seq=1)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)

###############################################################################
+ IPv4 / ESP - Tunnel - Encryption Algorithms

#######################################
= IPv4 / ESP - Tunnel - NULL - NULL
~ -crypto

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Tunnel - DES - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='DES', crypt_key=b'8bytekey',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
* the encrypted packet should have an ESP layer
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Tunnel - 3DES - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='3DES', crypt_key=b'threedifferent8byteskeys',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
* the encrypted packet should have an ESP layer
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Tunnel - AES-CBC - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Tunnel - AES-CTR - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CTR', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Tunnel - Blowfish - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='Blowfish', crypt_key=b'sixteenbytes key',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Tunnel - CAST - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='CAST', crypt_key=b'sixteenbytes key',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

###############################################################################
+ IPv4 / ESP - Transport - Authentication Algorithms

#######################################
= IPv4 / ESP - Transport - NULL - HMAC-SHA1-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Transport - NULL - HMAC-SHA1-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Transport - NULL - SHA2-256-128

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-256-128', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Transport - NULL - SHA2-256-128 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-256-128', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Transport - NULL - SHA2-384-192

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-384-192', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Transport - NULL - SHA2-384-192 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-384-192', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Transport - NULL - SHA2-512-256

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-512-256', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Transport - NULL - SHA2-512-256 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-512-256', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Transport - NULL - HMAC-MD5-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-MD5-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Transport - NULL - HMAC-MD5-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-MD5-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Transport - NULL - AES-CMAC-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Transport - NULL - AES-CMAC-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

###############################################################################
+ IPv4 / ESP - Tunnel - Authentication Algorithms

#######################################
= IPv4 / ESP - Tunnel - NULL - HMAC-SHA1-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Tunnel - NULL - HMAC-SHA1-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Tunnel - NULL - SHA2-256-128

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-256-128', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Tunnel - NULL - SHA2-256-128 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-256-128', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Tunnel - NULL - SHA2-384-192

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-384-192', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Tunnel - NULL - SHA2-384-192 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-384-192', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Tunnel - NULL - SHA2-512-256

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-512-256', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Tunnel - NULL - SHA2-512-256 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='SHA2-512-256', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Tunnel - NULL - HMAC-MD5-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-MD5-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Tunnel - NULL - HMAC-MD5-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-MD5-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Tunnel - NULL - AES-CMAC-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Tunnel - NULL - AES-CMAC-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

###############################################################################
+ IPv4 / ESP - Encryption + Authentication

#######################################
= IPv4 / ESP - Transport - AES-CBC - HMAC-SHA1-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Transport - AES-CBC - HMAC-SHA1-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Transport - AES-CBC - HMAC-SHA2-256-128 -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('hello world')
p = IP(raw(p))
p

enc_key = bytes.fromhex("85ee354b4675a9c5d16e3d6f4118043b")
auth_key = bytes.fromhex("6f79bf94da7dde3c86009934d9258f1b3fc2f5382aca9c9cb8e216eed235f34c")

sa = SecurityAssociation(ESP, spi=0xcf54ccdf, crypt_algo='AES-CBC',
                         crypt_key=enc_key,
                         auth_algo='SHA2-256-128', auth_key=auth_key,
                         esn_en=True, esn=68)
e = sa.encrypt(p, iv=bytes.fromhex("11223344112233441122334411223344"))


assert bytes(e) == bytes.fromhex("4500006c000100004032745a0101010102020202cf54ccdf0000000111223344112233441122334411223344f5bda519c9ae64f283f0fc18a8d253eca8b34c2120c8958a97ec9d8e67756da2523fce9b5541c57fddf090afc2bfd97e8703203953f853eb61482e4c1384d4c8")

* integrity verification should pass
d = sa.decrypt(e)
d

#######################################
= IPv4 / ESP - Transport - AES-GCM - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

# Generated with Linux 4.4.0-62-generic #83-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 546 reqid 1 \
#    mode tunnel aead 'rfc4106(gcm(aes))' '0x3136627974656b65792b34627974656e6f6e6365' 128 flag align4
ref = IP() \
    / ESP(spi=0x222,
          data=b'\x66\x00\x28\x86\xe9\xdf\xc5\x24\xb0\xbd\xfd\x62\x61\x7e\xd3\x76'
               b'\x7b\x48\x28\x8e\x76\xaa\xea\x48\xb8\x40\x30\x8a\xce\x50\x71\xbb'
               b'\xc0\xb2\x47\x71\xd7\xa4\xa0\xcb\x03\x68\xd3\x16\x5a\x7c\x37\x84'
               b'\x87\xc7\x19\x59\xb4\x7c\x76\xe3\x48\xc0\x90\x4b\xd2\x36\x95\xc1'
               b'\xb7\xa4\xb6\x7b\x89\xe6\x4f\x10\xae\xdb\x84\x47\x46\x00\xb4\x44'
               b'\xe6\x6d\x16\x55\x5f\x82\x36\xa5\x49\xf7\x52\x81\x65\x90\x4d\x28'
               b'\x92\xb2\xe3\xf1\xa4\x02\xd2\x37\xac\x0b\x7a\x10\xcf\x64\x46\xb9',
          seq=1)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)

#######################################
= IPv4 / ESP - Transport - AES-GCM - NULL -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None, esn_en = True, esn = 0x1)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

# Generated with Linux 4.4.0-62-generic #83-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 546 reqid 1 \
#    mode tunnel aead 'rfc4106(gcm(aes))' '0x3136627974656b65792b34627974656e6f6e6365' 128 flag align4
ref = IP() \
    / ESP(spi=0x222,
          data=b'\x66\x00\x28\x86\xe9\xdf\xc5\x24\xb0\xbd\xfd\x62\x61\x7e\xd3\x76'
               b'\x7b\x48\x28\x8e\x76\xaa\xea\x48\xb8\x40\x30\x8a\xce\x50\x71\xbb'
               b'\xc0\xb2\x47\x71\xd7\xa4\xa0\xcb\x03\x68\xd3\x16\x5a\x7c\x37\x84'
               b'\x87\xc7\x19\x59\xb4\x7c\x76\xe3\x48\xc0\x90\x4b\xd2\x36\x95\xc1'
               b'\xb7\xa4\xb6\x7b\x89\xe6\x4f\x10\xae\xdb\x84\x47\x46\x00\xb4\x44'
               b'\xe6\x6d\x16\x55\x5f\x82\x36\xa5\x49\xf7\x52\x81\x65\x90\x4d\x28'
               b'\xfe\x4d\x22\x83\x6a\x81\x0d\x60\x94\xdb\x45\x22\x03\x92\xf6\x94',
          seq=1)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)


#######################################

= IPv4 / ESP - Transport - AES-GCM - NULL - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err
    
#######################################

= IPv4 / ESP - Transport - AES-GCM - NULL - altered packet -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None, esn_en = True, esn = 0x200)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
* integrity verification should fail
try:
    d = sa.decrypt(e, esn = 0x201)
    assert False
except IPSecIntegrityError as err:
    err
    
#######################################
= IPv4 / ESP - Transport - AES-NULL-GMAC - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-NULL-GMAC', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* AES-NULL-GMAC is integrity only, the original packet payload should be readable
assert b'testdata' in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

# Generated with Linux 5.15.0-1034-azure #41-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 0x222 reqid 1 \
#    mode tunnel aead 'rfc4543(gcm(aes))' '0x3136627974656b65792b34627974656e6f6e6365' 128 flag align4
ref = IP() \
    / ESP(spi=0x222,
          data=b'\x54\x70\x6c\x6a\x9f\xba\xa6\x18\x45\x00\x00\x54\xbc\x53\x00\x00'
               b'\x40\x01\xa9\x59\x0a\x7d\x00\x01\x0a\x7d\x00\x02\x00\x00\xad\x53'
               b'\xa8\x83\x00\x01\x02\xe6\x09\x64\x00\x00\x00\x00\xd9\x0a\x06\x00'
               b'\x00\x00\x00\x00\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b'
               b'\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b'
               b'\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x01\x02\x02\x04'
               b'\x9b\x76\x32\x30\xf6\x49\x92\xa8\x8f\x6a\x20\x87\x2c\x74\x0c\x18',
          seq=22)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)

#######################################
= IPv4 / ESP - Transport - AES-NULL-GMAC - NULL -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-NULL-GMAC', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None, esn_en = True, esn = 0x1)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* AES-NULL-GMAC is integrity only, the original packet payload should be readable
assert b'testdata' in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

# Generated with Linux 5.15.0-1034-azure #41-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 0x222 reqid 1 replay-oseq-hi 0x1 \
#    mode tunnel aead 'rfc4543(gcm(aes))' '0x3136627974656b65792b34627974656e6f6e6365' 128 flag align4 esn
ref = IP() \
    / ESP(spi=0x222,
          data=b'\x43\xe6\xa1\xce\x70\x9d\x67\xf4\x45\x00\x00\x54\x2e\x4a\x40\x00'
               b'\x40\x01\xf7\x62\x0a\x7d\x00\x02\x0a\x7d\x00\x01\x08\x00\xd3\x32'
               b'\x8f\x4c\x00\x02\x8d\xec\x09\x64\x00\x00\x00\x00\x3c\x5b\x03\x00'
               b'\x00\x00\x00\x00\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b'
               b'\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b'
               b'\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x01\x02\x02\x04'
               b'\x76\xd4\x93\x90\x75\xee\x3f\xa3\xf3\xcf\xcc\x27\xf5\x5b\x12\xb6',
          seq=5)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)


#######################################

= IPv4 / ESP - Transport - AES-NULL-GMAC - NULL - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-NULL-GMAC', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* AES-NULL-GMAC is integrity only, the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################

= IPv4 / ESP - Transport - AES-NULL-GMAC - NULL - altered packet -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-NULL-GMAC', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None, esn_en = True, esn = 0x200)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* AES-NULL-GMAC is integrity only, the original packet payload should be readable
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
* integrity verification should fail
try:
    d = sa.decrypt(e, esn = 0x201)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Transport - AES-CCM - NULL
~ crypto_advanced

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CCM', crypt_key=b'16bytekey3bytenonce',
                         crypt_icv_size=8,
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d == p

# Generated with Linux 4.4.0-62-generic #83-Ubuntu
# ip xfrm state add src 10.125.0.2 dst 10.125.0.1 proto esp spi 546 reqid 1 \
#    mode tunnel aead 'rfc4309(ccm(aes))' '0x3136627974656b657933627974656e6f6e6365' 64
ref = IP() \
    / ESP(spi=0x222,
          data=b'\x2e\x02\x9f\x1f\xad\x76\x80\x58\x8f\xeb\x45\xf1\x66\xe3\xad\xa6'
               b'\x90\x1b\x2b\x7d\xd3\x3d\xa4\x53\x35\xc8\xfa\x92\xfd\xd7\x42\x2f'
               b'\x87\x60\x9b\x46\xb0\x21\x5e\x82\xfb\x2f\x59\xba\xf0\x6c\xe5\x51'
               b'\xb8\x36\x20\x88\xfe\x49\x86\x60\xe8\x0a\x3d\x36\xb5\x8a\x08\xa9'
               b'\x5e\xe3\x87\xfa\x93\x3f\xe8\xc2\xc5\xbf\xb1\x2e\x6f\x7d\xc5\xa5'
               b'\xd8\xe5\xf3\x25\x21\x81\x43\x16\x48\x10\x7c\x04\x31\x20\x07\x7c'
               b'\x7b\xda\x5d\x1a\x72\x45\xc4\x79',
          seq=1)

d_ref = sa.decrypt(ref)
d_ref

* Check for ICMP layer in decrypted reference
assert d_ref.haslayer(ICMP)

#######################################
= IPv4 / ESP - Transport - AES-CCM - NULL - altered packet
~ crypto_advanced

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CCM', crypt_key=b'16bytekey3bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Tunnel - AES-CBC - HMAC-SHA1-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Tunnel - AES-CBC - HMAC-SHA1-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / ESP - Tunnel - AES-GCM - NULL

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

#######################################
= IPv4 / ESP - Tunnel - AES-GCM - NULL -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'), esn_en = True, esn = 0x2)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

#######################################

= IPv4 / ESP - Tunnel - AES-GCM - NULL - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err
    
#######################################

= IPv4 / ESP - Tunnel - AES-GCM - NULL - altered packet - ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'), esn_en = True, esn = 0x2)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
* integrity verification should fail
try:
    d = sa.decrypt(e, esn = 0x3)
    assert False
except IPSecIntegrityError as err:
    err    

#######################################
= IPv4 / ESP - Tunnel - AES-CTR - NULL - verify no cipher align padding

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= UDP(sport=1000, dport=1001)
p /= Raw("\x00" * 3)
p
print("len p: {}".format(len(p)))

# oiphdr esphdr iiphdr udphdr data esptail iv
#   20  +  8   +  20  +  8   + 3   +  2   + 8 = 69
# CipherInput: iiphdr udphdr data esptail
#                20  +  8   + 3   +  2   = 33
#   good: (33 % 4) == 1, pad == (4-1) == 3, len == 36+33+3 == 72
#   bad: (33 % 16) == 1, pad == (16-1) == 15, len == 36+33+15 == 84

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CTR', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))
print("crypt_algo.icv_size {}".format(sa.crypt_algo.icv_size))
print("auth_algo.icv_size {}".format(sa.auth_algo.icv_size))

e = sa.encrypt(p)
e
print("len e: {}".format(len(e)))

esp = sa.crypt_algo.decrypt(sa, e[ESP], sa.crypt_key,
                            sa.crypt_algo.icv_size or
                            sa.auth_algo.icv_size,
                            esn_en=sa.esn_en,
                            esn=sa.esn)
esp
print("len(esp.data): {}".format(len(esp.data)))

* after encryption packet should be padded for 4 byte alignment
assert len(e) == 72 and esp.padlen == 3, "bad length/padding {}/{}".format(len(e), esp.padlen)

#######################################
= IPv4 / ESP - Tunnel - AES-GCM - NULL - verify no cipher align padding

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= UDP(sport=1000, dport=1001)
p /= Raw("\x00" * 1418)
print("len p: {}".format(len(p)))

# oiphdr esphdr iiphdr udphdr data esptail iv icv
#   20  +  8   +  20  +  8   +1418 + 2    +8 +16 = 1500
# CipherInput: iiphdr udphdr data esptail
#                20  +  8   +1418 + 2 = 1448
#   good: (1448 % 4) == 0, pad == 0, len == 52+1448+0 == 1500
#   bad: (1448 % 16) == 8, pad == (16-8) == 8, len == 52+1448+8 == 1508

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
print("len e: {}".format(len(e)))

esp = sa.crypt_algo.decrypt(sa, e[ESP], sa.crypt_key,
                            sa.crypt_algo.icv_size or
                            sa.auth_algo.icv_size,
                            esn_en=sa.esn_en,
                            esn=sa.esn)
print("len(esp.data): {}".format(len(esp.data)))

* after encryption packet should be padded for 4 byte alignment
assert len(e) == 1500 and esp.padlen == 0, "bad length/padding {}/{}".format(len(e), esp.padlen)

#######################################
= IPv4 / ESP - Tunnel - AES-CCM - NULL
~ crypto_advanced

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CCM', crypt_key=b'16bytekey3bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d == p

#######################################
= IPv4 / ESP - Tunnel - AES-CCM - NULL
~ crypto_advanced

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CCM', crypt_key=b'16bytekey3bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

###############################################################################
+ IPv4 / AH - Transport

#######################################
= IPv4 / AH - Transport - HMAC-SHA1-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'sixteenbytes key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / AH - Transport - HMAC-SHA1-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'sixteenbytes key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before decryption
e[TCP].sport = 5

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Transport - SHA2-256-128

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-256-128', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / AH - Transport - SHA2-256-128 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-256-128', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e[TCP].dport = 46

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Transport - SHA2-384-192

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-384-192', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / AH - Transport - SHA2-384-192 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-384-192', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e[TCP].dport = 46

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Transport - SHA2-512-256

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-512-256', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / AH - Transport - SHA2-512-256 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-512-256', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e[TCP].dport = 46

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Transport - HMAC-MD5-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-MD5-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / AH - Transport - HMAC-MD5-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-MD5-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e[TCP].dport = 46

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Transport - AES-CMAC-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / AH - Transport - AES-CMAC-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key')

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e[TCP].dport = 46

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Transport - AES-CMAC-96 -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key',
                         esn_en=True, esn=0x200)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / AH - Transport - AES-CMAC-96 - altered packet -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key',
                         esn_en=True, esn=0x200)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an AH layer
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e[TCP].dport = 46

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

###############################################################################
+ IPv4 / AH - Tunnel

#######################################
= IPv4 / AH - Tunnel - HMAC-SHA1-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / AH - Tunnel - HMAC-SHA1-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e.dst = '4.4.4.4'

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Tunnel - SHA2-256-128

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-256-128', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d == p

#######################################
= IPv4 / AH - Tunnel - SHA2-256-128 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-256-128', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e.dst = '4.4.4.4'

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Tunnel - SHA2-384-192

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-384-192', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d == p

#######################################
= IPv4 / AH - Tunnel - SHA2-384-192 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-384-192', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e.dst = '4.4.4.4'

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Tunnel - SHA2-512-256

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-512-256', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d == p

#######################################
= IPv4 / AH - Tunnel - SHA2-512-256 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-512-256', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e.dst = '4.4.4.4'

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Tunnel - HMAC-MD5-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-MD5-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d == p

#######################################
= IPv4 / AH - Tunnel - HMAC-MD5-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-MD5-96', auth_key=b'secret key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e.dst = '4.4.4.4'

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Tunnel - AES-CMAC-96

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d == p

#######################################
= IPv4 / AH - Tunnel - AES-CMAC-96 - altered packet

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e.dst = '4.4.4.4'

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv4 / AH - Tunnel - AES-CMAC-96 -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'),
                         esn_en=True, esn=0x200)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.ttl = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet should be unaltered
assert d == p

#######################################
= IPv4 / AH - Tunnel - AES-CMAC-96 - altered packet -- ESN

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='AES-CMAC-96', auth_key=b'sixteenbytes key',
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'),
                         esn_en=True, esn=0x200)

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
assert e.proto == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e.dst = '4.4.4.4'

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

###############################################################################
+ IPv4 / UDP / ESP - NAT-Traversal

#######################################
= IPv4 / UDP / ESP - NAT-Traversal - Tunnel
~ -crypto

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IP(src='11.11.11.11', dst='22.22.22.22'),
                         nat_t_header=UDP(dport=5000))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == '11.11.11.11' and e.dst == '22.22.22.22'
assert e.chksum != p.chksum
* the encrypted packet should have an UDP layer
assert e.proto == socket.IPPROTO_UDP
assert e.haslayer(UDP)
assert e[UDP].sport == 4500
assert e[UDP].dport == 5000
assert e[UDP].chksum == 0
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv4 / UDP / ESP - NAT-Traversal - Transport
~ -crypto

import socket

p = IP(src='1.1.1.1', dst='2.2.2.2')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IP(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='NULL', auth_key=None,
                         nat_t_header=UDP(dport=5000))

e = sa.encrypt(p)
e

assert isinstance(e, IP)
assert e.src == '1.1.1.1' and e.dst == '2.2.2.2'
assert e.chksum != p.chksum
* the encrypted packet should have an UDP layer
assert e.proto == socket.IPPROTO_UDP
assert e.haslayer(UDP)
assert e[UDP].sport == 4500
assert e[UDP].dport == 5000
assert e[UDP].chksum == 0
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

###############################################################################
= IPv6 / ESP - NAT-Traversal - Transport
~ -crypto

import socket

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=3333, dport=55)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='NULL', auth_key=None,
                         nat_t_header=UDP(dport=5000))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.chksum != p.chksum
* the encrypted packet should have an UDP layer
assert e.nh == socket.IPPROTO_UDP
assert e.haslayer(UDP)
assert e[UDP].sport == 4500
assert e[UDP].dport == 5000
assert e[UDP].chksum == 0
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]
assert not d.haslayer(UDP)
assert d[Raw] == p[Raw]
###############################################################################
+ IPv6 / ESP

#######################################
= IPv6 / ESP - Transport - NULL - NULL
~ -crypto

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Transport - AES-CBC - NULL

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Transport - NULL - HMAC-SHA1-96

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Transport - NULL - HMAC-SHA1-96 - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / ESP - Transport - AES-CBC - HMAC-SHA1-96

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Transport - AES-CBC - HMAC-SHA1-96 - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / ESP - Transport - AES-GCM - NULL

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Transport - AES-GCM - NULL - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / ESP - Transport - AES-CCM - NULL
~ crypto_advanced

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CCM', crypt_key=b'16bytekey3bytenonce',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Transport - AES-CCM - NULL - altered packet
~ crypto_advanced

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CCM', crypt_key=b'16bytekey3bytenonce',
                         auth_algo='NULL', auth_key=None)

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / ESP - Tunnel - NULL - NULL
~ -crypto

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Tunnel - AES-CBC - NULL

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Tunnel - NULL - HMAC-SHA1-96

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

* integrity verification should pass
d = sa.decrypt(e)

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Tunnel - NULL - HMAC-SHA1-96 - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='NULL', crypt_key=None,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
assert b'testdata' in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].data = e[ESP].data.replace(b'\x01', b'\x21')

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / ESP - Tunnel - AES-CBC - HMAC-SHA1-96

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Tunnel - AES-CBC - HMAC-SHA1-96 - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CBC', crypt_key=b'sixteenbytes key',
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / ESP - Tunnel - AES-GCM - NULL

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Tunnel - AES-GCM - NULL - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-GCM', crypt_key=b'16bytekey+4bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / ESP - Tunnel - AES-CCM - NULL
~ crypto_advanced

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CCM', crypt_key=b'16bytekey3bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

d = sa.decrypt(e)
d

* after decryption original packet should be preserved
assert d[TCP] == p[TCP]

#######################################
= IPv6 / ESP - Tunnel - AES-CCM - NULL - altered packet
~ crypto_advanced

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(ESP, spi=0x222,
                         crypt_algo='AES-CCM', crypt_key=b'16bytekey3bytenonce',
                         auth_algo='NULL', auth_key=None,
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_ESP
assert e.haslayer(ESP)
assert not e.haslayer(TCP)
assert e[ESP].spi == sa.spi
* after encryption the original packet payload should NOT be readable
assert b'testdata' not in e[ESP].data

* simulate the alteration of the packet before decryption
e[ESP].seq += 1

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
###############################################################################
+ IPv6 / AH

#######################################
= IPv6 / AH - Transport - HMAC-SHA1-96

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
* the encrypted packet should have an AH layer
assert e.nh == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.hlim = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / AH - Transport - HMAC-SHA1-96 - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
* the encrypted packet should have an AH layer
assert e.nh == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e[TCP].dport = 46

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / AH - Transport - SHA2-256-128

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-256-128', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
* the encrypted packet should have an AH layer
assert e.nh == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.hlim = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d[TCP] == p[TCP]

#######################################
= IPv6 / AH - Transport - SHA2-256-128 - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-256-128', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
assert e.src == '11::22' and e.dst == '22::11'
* the encrypted packet should have an AH layer
assert e.nh == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e[TCP].dport = 46

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / AH - Tunnel - HMAC-SHA1-96

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.hlim = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d == p

#######################################
= IPv6 / AH - Tunnel - HMAC-SHA1-96 - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key',
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e.src = 'cc::ee'

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

#######################################
= IPv6 / AH - Tunnel - SHA2-256-128

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-256-128', auth_key=b'secret key',
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* alter mutable fields in the packet
e.hlim = 2

* integrity verification should pass
d = sa.decrypt(e)
d

* after decryption the original packet payload should be unaltered
assert d == p

#######################################
= IPv6 / AH - Tunnel - SHA2-256-128 - altered packet

p = IPv6(src='11::22', dst='22::11')
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='SHA2-256-128', auth_key=b'secret key',
                         tunnel_header=IPv6(src='aa::bb', dst='bb::aa'))

e = sa.encrypt(p)
e

assert isinstance(e, IPv6)
* after encryption packet should be encapsulated with the given ip tunnel header
assert e.src == 'aa::bb' and e.dst == 'bb::aa'
assert e.nh == socket.IPPROTO_AH
assert e.haslayer(AH)
assert e.haslayer(TCP)
assert e[AH].spi == sa.spi

* simulate the alteration of the packet before verification
e.src = 'cc::ee'

* integrity verification should fail
try:
    d = sa.decrypt(e)
    assert False
except IPSecIntegrityError as err:
    err

###############################################################################
+ IPv6 + Extensions / AH

#######################################
= IPv6 + Extensions / AH - Transport

p = IPv6(src='11::22', dst='22::11')
p /= IPv6ExtHdrHopByHop()
p /= IPv6ExtHdrDestOpt()
p /= IPv6ExtHdrRouting()
p /= IPv6ExtHdrDestOpt()
p /= IPv6ExtHdrFragment()
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert e.src == '11::22' and e.dst == '22::11'
* AH header should be inserted between the routing header and the dest options header
assert isinstance(e[AH].underlayer, IPv6ExtHdrRouting)
assert isinstance(e[AH].payload, IPv6ExtHdrDestOpt)

#######################################
= IPv6 + Routing Header / AH - Transport

p = IPv6(src='11::22', dst='22::11')
p /= IPv6ExtHdrHopByHop()
p /= IPv6ExtHdrRouting(addresses=['aa::bb', 'cc::dd', 'ee::ff'])
p /= TCP(sport=45012, dport=80)
p /= Raw('testdata')
p = IPv6(raw(p))
p

sa = SecurityAssociation(AH, spi=0x222,
                         auth_algo='HMAC-SHA1-96', auth_key=b'secret key')

e = sa.encrypt(p)
e

assert e.src == '11::22' and e.dst == '22::11'
* AH header should be inserted between the routing header and TCP
assert isinstance(e[AH].underlayer, IPv6ExtHdrRouting)
assert isinstance(e[AH].payload, TCP)

* reorder the routing header as the receiver will get it
final = e[IPv6ExtHdrRouting].addresses.pop()
e[IPv6ExtHdrRouting].addresses.insert(0, e.dst)
e.dst = final
e[IPv6ExtHdrRouting].segleft = 0

* integrity verification should pass
d = sa.decrypt(e)
d

