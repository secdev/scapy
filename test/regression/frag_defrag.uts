% Regression tests for Scapy

# More information at http://www.secdev.org/projects/UTscapy/

############
############
+ Test fragment() / defragment() functions

= fragment()
payloadlen, fragsize = 100, 8
assert fragsize % 8 == 0
fragcount = (payloadlen // fragsize) + bool(payloadlen % fragsize)
* create the packet
pkt = IP() / ("X" * payloadlen)
* create the fragments
frags = fragment(pkt, fragsize)
* count the fragments
assert len(frags) == fragcount
* each fragment except the last one should have MF set
assert all(p.flags == 1 for p in frags[:-1])
assert frags[-1].flags == 0
* each fragment except the last one should have a payload of fragsize bytes
assert all(len(p.payload) == 8 for p in frags[:-1])
assert len(frags[-1].payload) == ((payloadlen % fragsize) or fragsize)

= fragment() and overloaded_fields
pkt1 = Ether() / IP() / UDP()
pkt2 = fragment(pkt1)[0]
pkt3 = pkt2.__class__(raw(pkt2))
assert pkt1[IP].proto == pkt2[IP].proto == pkt3[IP].proto

= fragment() already fragmented packets
payloadlen = 1480 * 3
ffrags = fragment(IP() / ("X" * payloadlen), 1480)
ffrags = fragment(ffrags, 1400)
len(ffrags) == 6
* each fragment except the last one should have MF set
assert all(p.flags == 1 for p in ffrags[:-1])
assert ffrags[-1].flags == 0
* fragment offset should be well computed
plen = 0
for p in ffrags:
    assert p.frag == plen // 8
    plen += len(p.payload)

assert plen == payloadlen

= fragment() with non-multiple-of-8 MTU
paylen = 1400 + 1
frags1 = fragment(IP() / ("X" * paylen), paylen)
assert len(frags1) == 1
frags2 = fragment(IP() / ("X" * (paylen + 1)), paylen)
assert len(frags2) == 2
assert len(frags2[0]) == 20 + paylen - paylen % 8
assert len(frags2[1]) == 20 + 1 + paylen % 8

= defrag()
nonfrag, unfrag, badfrag = defrag(frags)
assert not nonfrag
assert not badfrag
assert len(unfrag) == 1

= defragment()
defrags = defragment(frags)
* we should have one single packet
assert len(defrags) == 1
* which should be the same as pkt reconstructed
assert defrags[0] == IP(raw(pkt))

= defragment() uses timestamp of last fragment
payloadlen, fragsize = 100, 8
assert fragsize % 8 == 0
packet = Ether()/IP()/("X" * payloadlen)
frags = fragment(packet, fragsize)
for i,frag in enumerate(frags):
    frag.time -= 100 + i

last_time = max(frag.time for frag in frags)
defrags = defragment(frags)
assert defrags[0].time == last_time
nonfrag, defrags, badfrag = defrag(frags)
assert defrags[0].time == last_time

= defragment() - Missing fragments

pkts = fragment(IP(dst="10.0.0.5")/ICMP()/("X"*1500))
assert len(defragment(pkts[1:])) == 1

= defrag() / defragment() - Real DNS packets

import base64

a = base64.b64decode('bnmYJ63mREVTUwEACABFAAV0U8UgADIR+u0EAgIECv0DxAA1sRIL83Z7gbCBgAABAB0AAAANA255YwNnb3YAAP8AAcAMAAYAAQAAA4QAKgZ2d2FsbDDADApob3N0bWFzdGVywAx4Og5wAAA4QAAADhAAJOoAAAACWMAMAC4AAQAAA4QAmwAGCAIAAAOEWWm9jVlgdP0mfQNueWMDZ292AHjCDBL0C1rEKUjsuG6Zg3+Rs6gj6llTABm9UZnWk+rRu6nPqW4N7AEllTYqNK+r6uFJ2KhfG3MDPS1F/M5QCVR8qkcbgrqPVRBJAG67/ZqpGORppQV6ib5qqo4ST5KyrgKpa8R1fWH8Fyp881NWLOZekM3TQyczcLFrvw9FFjdRwAwAAQABAAADhAAEobkenMAMAC4AAQAAA4QAmwABCAIAAAOEWWm9jVlgdP0mfQNueWMDZ292ABW8t5tEv9zTLdB6UsoTtZIF6Kx/c4ukIud8UIGM0XdXnJYx0ZDyPDyLVy2rfwmXdEph3KBWAi5dpRT16nthlMmWPQxD1ecg9rc8jcaTGo8z833fYJjzPT8MpMTxhapu4ANSBVbv3LRBnce2abu9QaoCdlHPFHdNphp6JznCLt4jwAwAMAABAAADhAEIAQEDCAMBAAF77useCfI+6T+m6Tsf2ami8/q5XDtgS0Ae7F0jUZ0cpyYxy/28DLFjJaS57YiwAYaabkkugxsoSv9roqBNZjD+gjoUB+MK8fmfaqqkSOgQuIQLZJeOORWD0gAj8mekw+S84DECylbKyYEGf8CB3/59IfV+YkTcHhXBYrMNxhMK1Eiypz4cgYxXiYUSz7jbOmqE3hU2GinhRmNW4Trt4ImUruSO+iQbTTj6LtCtIsScOF4vn4gcLJURLHOs+mf1NU9Yqq9mPC9wlYZk+8rwqcjVIiRpDmmv83huv4be1x1kkz2YqTFwtc33Fzt6SZk96Qtk2wCgg8ZQqLKGx5uwIIyrwAwAMAABAAADhAEIAQEDCAMBAAGYc7SWbSinSc3u8ZcYlO0+yZcJD1vqC5JARxZjKNzszHxc9dpabBtR9covySVu1YaBVrlxNBzfyFd4PKyjvPcBER5sQImoCikC+flD5NwXJbnrO1SG0Kzp8XXDCZpBASxuBF0vjUSU9yMqp0FywCrIfrbfCcOGAFIVP0M2u8dVuoI4nWbkRFc0hiRefoxc1O2IdpR22GAp2OYeeN2/tnFBz/ZMQitU2IZIKBMybKmWLC96tPcqVdWJX6+M1an1ox0+NqBZuPjsCx0/lZbuB/rLHppJOmkRc7q2Fw/tpHOyWHV+ulCfXem9Up/sbrMcP7uumFz0FeNhBPtg3u5kA5OVwAwAMAABAAADhACIAQADCAMBAAF5mlzmmq8cs6Hff0qZLlGKYCGPlG23HZw2qAd7N2FmrLRqPQ0R/hbnw54MYiIs18zyfm2J+ZmzUvGd+gjHGx3ooRRffQQ4RFLq6g6oxaLTbtvqPFbWt4Kr2GwX3UslgZCzH5mXLNpPI2QoetIcQCNRdcxn5QpWxPppCVXbKdNvvcAMADAAAQAAA4QAiAEAAwgDAQABqeGHtNFc0Yh6Pp/aM+ntlDW1fLwuAWToGQhmnQFBTiIUZlH7QMjwh5oMExNp5/ABUb3qBsyk9CLanRfateRgFJCYCNYofrI4S2yqT5X9vvtCXeIoG/QqMSl3PJk4ClYufIKjMPgl5IyN6yBIMNmmsATlMMu5TxM68a/CLCh92L3ADAAuAAEAAAOEAJsAMAgCAAADhFlpvY1ZYHT9Jn0DbnljA2dvdgAViVpFoYwy9dMUbOPDHTKt/LOtoicvtQbHeXiUSQeBkGWTLyiPc/NTW9ZC4WK5AuSj/0+V')
b = base64.b64decode('bnmYJ63mREVTUwEACABFAAV0U8UgrDIR+kEEAgIECv0DxApz1F5olFRytjhNlG/JbdW0NSAFeUUF4rBRqsly/h6nFWKoQfih35Lm+BFLE0FoMaikWCjGJQIuf0CXiElMSQifiDM+KTeecNkCgTXADAAuAAEAAAOEARsAMAgCAAADhFlpvY1ZYHT9VwUDbnljA2dvdgAdRZxvC6VlbYUVarYjan0/PlP70gSz1SiYCDZyw5dsGo9vrZd+lMcAm5GFjtKYDXeCb5gVuegzHSNzxDQOa5lVKLQZfXgVHsl3jguCpYwKAygRR3mLBGtnhPrbYcPGMOzIxO6/UE5Hltx9SDqKNe2+rtVeZs5FyHQE5pTVGVjNED9iaauEW9UF3bwEP3K+wLgxWeVycjNry/l4vt9Z0fyTU15kogCZG8MXyStJlzIgdzVZRB96gTJbGBDRFQJfbE2Af+INl0HRY4p+bqQYwFomWg6Tzs30LcqAnkptknb5peUNmQTBI/MU00A6NeVJxkKK3+lf2EuuiJl+nFpfWiKpwAwAMwABAAADhAAJAQAADASqu8zdwAwALgABAAADhACbADMIAgAAA4RZab2NWWB0/SZ9A255YwNnb3YAVhcqgSl33lqjLLFR8pQ2cNhdX7dKZ2gRy0vUHOa+980Nljcj4I36rfjEVJCLKodpbseQl0OeTsbfNfqOmi1VrsypDl+YffyPMtHferm02xBK0agcTMdP/glpuKzdKHTiHTlnSOuBpPnEpgxYPNeBGx8yzMvIaU5rOCxuO49Sh/PADAACAAEAAAOEAAoHdndhbGw0YcAMwAwAAgABAAADhAAKB3Z3YWxsMmHADMAMAAIAAQAAA4QACgd2d2FsbDNhwAzADAACAAEAAAOEAAoHdndhbGwxYcAMwAwALgABAAADhACbAAIIAgAAA4RZab2NWWB0/SZ9A255YwNnb3YANn7LVY7YsKLtpH7LKhUz0SVsM/Gk3T/V8I9wIEZ4vEklM9hI92D2aYe+9EKxOts+/py6itZfANXU197pCufktASDxlH5eWSc9S2uqrRnUNnMUe4p3Jy9ZCGhiHDemgFphKGWYTNZUJoML2+SDzbv9tXo4sSbZiKJCDkNdzSv2lfADAAQAAEAAAOEAEVEZ29vZ2xlLXNpdGUtdmVyaWZpY2F0aW9uPWMycnhTa2VPZUxpSG5iY24tSXhZZm5mQjJQcTQzU3lpeEVka2k2ODZlNDTADAAQAAEAAAOEADc2dj1zcGYxIGlwNDoxNjEuMTg1LjIuMC8yNSBpcDQ6MTY3LjE1My4xMzIuMC8yNSBteCAtYWxswAwALgABAAADhACbABAIAgAAA4RZab2NWWB0/SZ9A255YwNnb3YAjzLOj5HUtVGhi/emNG90g2zK80hrI6gh2d+twgVLYgWebPeTI2D2ylobevXeq5rK5RQgbg2iG1UiTBnlKPgLPYt8ZL+bi+/v5NTaqHfyHFYdKzZeL0dhrmebRbYzG7tzOllcAOOqieeO29Yr4gz1rpiU6g75vkz6yQoHNfmNVMXADAAPAAEAAAOEAAsAZAZ2d2FsbDLADMAMAA8AAQAAA4QACwBkBnZ3YWxsNMAMwAwADwABAAADhAALAAoGdndhbGwzwAzADAAPAAEAAAOEAAsACgZ2d2FsbDXADMAMAA8AAQAAA4QACwAKBnZ3YWxsNsAMwAwADwABAAADhAALAAoGdndhbGw3wAzADAAPAAEAAAOEAAsACgZ2d2FsbDjADMAMAA8AAQAAA4QACwBkBnZ3YWxsMcAMwAwALgABAAADhACbAA8IAgAAA4RZab2NWWB0/SZ9A255YwNnb3YAooXBSj6PfsdBd8sEN/2AA4cvOl2bcioO')
c = base64.b64decode('bnmYJ63mREVTUwEACABFAAFHU8UBWDIRHcMEAgIECv0DxDtlufeCT1zQktat4aEVA8MF0FO1sNbpEQtqfu5Al//OJISaRvtaArR/tLUj2CoZjS7uEnl7QpP/Ui/gR0YtyLurk9yTw7Vei0lSz4cnaOJqDiTGAKYwzVxjnoR1F3n8lplgQaOalVsHx9UAAQABAAADLAAEobkBA8epAAEAAQAAAywABKG5AQzHvwABAAEAAAMsAASnmYIMx5MAAQABAAADLAAEp5mCDcn9AAEAAQAAAqUABKeZhAvKFAABAAEAAAOEAAShuQIfyisAAQABAAADhAAEobkCKcpCAAEAAQAAA4QABKG5AjPKWQABAAEAAAOEAAShuQI9ynAAAQABAAADhAAEobkCC8nPAAEAAQAAA4QABKG5AgzJ5gABAAEAAAOEAASnmYQMAAApIAAAAAAAAAA=')
d = base64.b64decode('////////REVTUwEACABFAABOawsAAIARtGoK/QExCv0D/wCJAIkAOry/3wsBEAABAAAAAAAAIEVKRkRFQkZFRUJGQUNBQ0FDQUNBQ0FDQUNBQ0FDQUFBAAAgAAEAABYP/WUAAB6N4XIAAB6E4XsAAACR/24AADyEw3sAABfu6BEAAAkx9s4AABXB6j4AAANe/KEAAAAT/+wAAB7z4QwAAEuXtGgAAB304gsAABTB6z4AAAdv+JAAACCu31EAADm+xkEAABR064sAABl85oMAACTw2w8AADrKxTUAABVk6psAABnF5joAABpA5b8AABjP5zAAAAqV9WoAAAUW+ukAACGS3m0AAAEP/vAAABoa5eUAABYP6fAAABX/6gAAABUq6tUAADXIyjcAABpy5Y0AABzb4yQAABqi5V0AAFXaqiUAAEmRtm4AACrL1TQAAESzu0wAAAzs8xMAAI7LcTQAABxN47IAAAbo+RcAABLr7RQAAB3Q4i8AAAck+NsAABbi6R0AAEdruJQAAJl+ZoEAABDH7zgAACOA3H8AAAB5/4YAABQk69sAAEo6tcUAABJU7asAADO/zEAAABGA7n8AAQ9L8LMAAD1DwrwAAB8F4PoAABbG6TkAACmC1n0AAlHErjkAABG97kIAAELBvT4AAEo0tcsAABtC5L0AAA9u8JEAACBU36sAAAAl/9oAABBO77EAAA9M8LMAAA8r8NQAAAp39YgAABB874MAAEDxvw4AAEgyt80AAGwsk9MAAB1O4rEAAAxL87QAADtmxJkAAATo+xcAAAM8/MMAABl55oYAACKh3V4AACGj3lwAAE5ssZMAAC1x0o4AAAO+/EEAABNy7I0AACYp2dYAACb+2QEAABB974IAABc36MgAAA1c8qMAAAf++AEAABDo7xcAACLq3RUAAA8L8PQAAAAV/+oAACNU3KsAABBv75AAABFI7rcAABuH5HgAABAe7+EAAB++4EEAACBl35oAAB7c4SMAADgJx/YAADeVyGoAACKN3XIAAA/C8D0AAASq+1UAAOHPHjAAABRI67cAAABw/48=')

old_debug_dissector = conf.debug_dissector
conf.debug_dissector = 0
plist = PacketList([Ether(x) for x in [a, b, c, d]])
conf.debug_dissector = old_debug_dissector

left, defragmented, errored = defrag(plist)
assert len(left) == 1
assert left[0] == Ether(d)
assert len(defragmented) == 1
assert len(defragmented[0]) == 3093
assert defragmented[0][DNSRR].rrname == b'nyc.gov.'
assert len(errored) == 0

plist_def = defragment(plist)
assert len(plist_def) == 2
assert len(plist_def[0]) == 3093
assert plist_def[0][DNSRR].rrname == b'nyc.gov.'

= Packet().fragment()
payloadlen, fragsize = 100, 8
assert fragsize % 8 == 0
fragcount = (payloadlen // fragsize) + bool(payloadlen % fragsize)
* create the packet
pkt = IP() / ("X" * payloadlen)
* create the fragments
frags = pkt.fragment(fragsize)
* count the fragments
assert len(frags) == fragcount
* each fragment except the last one should have MF set
assert all(p.flags == 1 for p in frags[:-1])
assert frags[-1].flags == 0
* each fragment except the last one should have a payload of fragsize bytes
assert all(len(p.payload) == 8 for p in frags[:-1])
assert len(frags[-1].payload) == ((payloadlen % fragsize) or fragsize)

= Packet().fragment() and overloaded_fields
pkt1 = Ether() / IP() / UDP()
pkt2 = pkt1.fragment()[0]
pkt3 = pkt2.__class__(raw(pkt2))
assert pkt1[IP].proto == pkt2[IP].proto == pkt3[IP].proto

= Packet().fragment() already fragmented packets
payloadlen = 1480 * 3
ffrags = (IP() / ("X" * payloadlen)).fragment(1480)
ffrags = reduce(lambda x, y: x + y, (pkt.fragment(1400) for pkt in ffrags))
len(ffrags) == 6
* each fragment except the last one should have MF set
assert all(p.flags == 1 for p in ffrags[:-1])
assert ffrags[-1].flags == 0
* fragment offset should be well computed
plen = 0
for p in ffrags:
    assert p.frag == plen / 8
    plen += len(p.payload)

assert plen == payloadlen

